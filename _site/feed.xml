<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-Hant"><generator uri="https://jekyllrb.com/" version="3.8.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh-Hant" /><updated>2018-05-09T12:12:39+08:00</updated><id>http://localhost:4000/</id><title type="html">High Performance Computing Laboratory</title><subtitle>HCLab
</subtitle><author><name>chadcoco1444</name><email>chadcoco1444@gmail.com</email></author><entry><title type="html">HCLab page</title><link href="http://localhost:4000/2018/05/09/HCLab-page.html" rel="alternate" type="text/html" title="HCLab page" /><published>2018-05-09T00:00:00+08:00</published><updated>2018-05-09T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/09/HCLab-page</id><content type="html" xml:base="http://localhost:4000/2018/05/09/HCLab-page.html">&lt;h1 id=&quot;here-is-an-example-for-post&quot;&gt;Here is an example for post&lt;/h1&gt;

&lt;h2 id=&quot;這是一個中文範例&quot;&gt;這是一個中文範例&lt;/h2&gt;</content><author><name>chadcoco1444</name><email>chadcoco1444@gmail.com</email></author><category term="Hclab" /><summary type="html">Here is an example for post 這是一個中文範例</summary></entry><entry><title type="html">Computer Organization Structure</title><link href="http://localhost:4000/2018/05/09/Computer-Organization-Structure.html" rel="alternate" type="text/html" title="Computer Organization Structure" /><published>2018-05-09T00:00:00+08:00</published><updated>2018-05-09T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/09/Computer-Organization-Structure</id><content type="html" xml:base="http://localhost:4000/2018/05/09/Computer-Organization-Structure.html">&lt;h1 id=&quot;計算機組織結構&quot;&gt;計算機組織結構&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;參考資料：http://www.ece.lsu.edu/ee4720/&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第01講-course-outline-625&quot;&gt;第01講 Course Outline (6/25)&lt;/h2&gt;
&lt;p&gt;Q: 為什麼電腦不用十進位而用二進位？
A: signal 的 voltage 只能分成 high 和 low =&amp;gt; 只能有兩種state&lt;/p&gt;

&lt;h3 id=&quot;電子電路&quot;&gt;電子電路：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;switch(n-type transistor):
    &lt;ul&gt;
      &lt;li&gt;three terminals: the source, the gate, and the drain.&lt;/li&gt;
      &lt;li&gt;開：
        &lt;ol&gt;
          &lt;li&gt;在 gate加電壓 =&amp;gt; 產生 eletron channel 在 source 和 drain 之間&lt;/li&gt;
          &lt;li&gt;在 source 和 drain 之間加電位差 =&amp;gt; 產生電流&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;關：移除 gate 的電壓
&lt;!--more--&gt;
        &lt;h3 id=&quot;數位電子學&quot;&gt;數位電子學&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有了開關就可以做邏輯閘，ex: NAND gate，NAND gate 是 function complete ，任何一個 boolean function 都可以用 NAND gate 表示出來&lt;/li&gt;
  &lt;li&gt;有了邏輯閘就可以做邏輯電路，也可以做記憶元件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;computer-architecture&quot;&gt;Computer Architecture&lt;/h3&gt;
&lt;p&gt;Q: What is Computer Architecture?
A: Computer Architecture = Instruction Set Architecture + Computer Organization&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Instruction Set 是一個 software 和 hardware 之間的 interface，software 不需要知道 hardware 怎麼實做，只需要知道有怎麼樣的 instruction，就可以根據 instruction 去發展 software；hardware 也不需要知道最後會執行哪些程式，只需要知道最後會有這些 instruction&lt;/li&gt;
  &lt;li&gt;Instruction Set 其實就是指 Assembly Language&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第02講-computers-history-626&quot;&gt;第02講 Computer’s history (6/26)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;feature size: 目前的技術可以做到的 source 到 drain 的最短距離&lt;/li&gt;
  &lt;li&gt;Moore’s low: 每18個月，一個 chip 上的 transistor 數目可以 double&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第0304講-computer-abstractions-and-technology-626&quot;&gt;第03.04講 Computer Abstractions and Technology (6/26)&lt;/h2&gt;
&lt;h3 id=&quot;performance&quot;&gt;Performance&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Response Time: how long it takes to do a task&lt;/li&gt;
  &lt;li&gt;Throughput: total work done per unit time&lt;/li&gt;
  &lt;li&gt;Elapsed time: total response time, include all aspects =&amp;gt; Determine system performance&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CPU time: Time spent processing a given job&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$performance = \frac{1}{Execution\ Time}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;X is n time faster than Y
$n = \frac{Performance_X}{Performance_Y} = \frac{Execution\ time_Y}{Execution\ time_X}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Clock period: duration of a clock cycle&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Clock frequency(clock rate): cycles per second&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\begin{equation}
 CPU\ time = CPU\ Clock\ Cycles \times Clock\ Cycle\ Time&lt;br /&gt;
 = \frac{CPU\ Clock\ Cycles}{Clock\ Rate}
 \end{equation}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果用更高階的觀點來看，則會考慮一個程式需要幾個 instruction 來完成
 $Clock\ Cycles = Instruction\ Count \times Cycles\ per\ Instruction(CPI)$
 $CPU\ Time = Instruction\ Count \times CPI \times Clock\ Cycle\ Time = \frac{Instruction\ Count \times CPI}{Clock\ Rate}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不同的 instruction 會有不同的 clock cycle
$Clock\ Cycles = \displaystyle\sum_{i = 1}^{n}(CPI_i \times Instruction\ Count_i)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Weighted average CPI
$CPI = \frac{\displaystyle\sum_{i = 1}^{n}(CPI_i \times Instruction\ Count_i)}{Instruction\ Count}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MIPS(Millions of Instruction Per Second)
$MIPS = \frac{Instruction\ Count}{Execution\ time \times 10^6} = \cfrac{Instruction\ Count}{\frac{Instruction\ Count \times CPI}{Clock\ Rate} \times 10 ^6} = \frac{Clock\ Rate}{CPI \times 10^6}$
    &lt;ul&gt;
      &lt;li&gt;MIPS並不能代表真正的 performance，因為不同機器一個 instruction 花的時間未必相同&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;performance-summary&quot;&gt;Performance Summary&lt;/h4&gt;
&lt;p&gt;$CPU\ Time = \frac{Seconds}{Program} = \frac{Instructions}{Program} \times \frac{Clock\ Cycles}{Instruction} \times \frac{Seconds}{Clock\ Cycle}$&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Amdahl’s Law
$T_{improved} = \frac{T_{affected}}{improvement\ factor} + T_{unaffected}$
    &lt;ul&gt;
      &lt;li&gt;告訴我們要 Make the common task fast&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;power-consumption&quot;&gt;Power Consumption&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Static Power Consumption: leakage power (漏電)&lt;/li&gt;
  &lt;li&gt;Dynamic Power Consumption: 從 0 變 1，1 變 0 所需的電
$Dynamic\ Power\ Consumption = Capacitive\ load \times Voltage^2 \times Frequency$
    &lt;ul&gt;
      &lt;li&gt;利用 voltage 降低的方式來讓 power 降低，但是因為 voltage 降低，leakage power 會變多，所以不能無止盡的降下去，如果在單位面積裡面再做更多的運算（電晶體變更多）的話，power density 會提高，產生的熱也會變多，所以 power 的問題成為發展這個 technology 的限制 =&amp;gt; 不再 focus 在 unicore 的 performance，往 multicore 的方向發展&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第0509講-instruction-set-architecture-627&quot;&gt;第05～09講 Instruction set architecture (6/27)&lt;/h2&gt;
&lt;h3 id=&quot;mips-register-convention&quot;&gt;MIPS Register Convention:&lt;/h3&gt;
&lt;p&gt;|Name|Resister Number|Usuage|
|:—-:|:—-:|:—-|
|$zero|0|constant 0|
|$at|1|reserved for assembler|
|$v0-$v1|2-3|expression evaluation &amp;amp; function results|
|$a0-$a3|4-7|arguments|
|$t0-$t7|8-15|temporary: caller saves|
|$s0-$s7|16-23|callee saves|
|$t8-$t9|24-25|temporary|
|$k0-$k1|26-27|reserved for OS kernel|
|$gp|28|pointer to global area|
|$sp|29|stack pointer|
|$fp|30|frame pointer|
|$ra|31|return address|&lt;/p&gt;

&lt;h3 id=&quot;r-type-instruction&quot;&gt;R Type Instruction&lt;/h3&gt;
&lt;p&gt;|op|rs|rt|rd|shamt|funct
|:—-:|:—-:|:—-|-|-|-|
|6 bits|5 bits|5 bits|5 bits|5 bits|6 bits|&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;opcode: 0 for all R type instruction&lt;/li&gt;
  &lt;li&gt;rs (source register): generally used to specify register containing first operand&lt;/li&gt;
  &lt;li&gt;rt (target register): generally used to specify register containing second operand&lt;/li&gt;
  &lt;li&gt;rd (destination register): generally used to specify register which will receive result of computation&lt;/li&gt;
  &lt;li&gt;shamt: shift amount&lt;/li&gt;
  &lt;li&gt;funct: conbined with opcode to specify the instruction
Q: 為什麼不直接把 opcode 的長度增加就好？
A: 因為如果把 opcode 的長度增加，i type 和 j type opcode 的長度也要增加，那 i type 的 immediate 的長度和 j type 的 target address 的長度就會減少&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;add, sub, and, or, slt(set on less than)
    &lt;ul&gt;
      &lt;li&gt;usuage: operator rd, rs, rt&lt;/li&gt;
      &lt;li&gt;ex: add $s0, $s1, $s2&lt;/li&gt;
      &lt;li&gt;slt: if (rs &amp;lt; rt) rd = 1; else rd = 0;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;sll(shift left logical), srl, sra(shift right arithmatic)
    &lt;ul&gt;
      &lt;li&gt;usuage: operator rd, rt, shamt&lt;/li&gt;
      &lt;li&gt;ex: srl $s0, $s1, 4&lt;/li&gt;
      &lt;li&gt;rs is unused&lt;/li&gt;
      &lt;li&gt;sra: shift right with signed extention&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;i-type-instruction&quot;&gt;I Type Instruction&lt;/h3&gt;
&lt;p&gt;|op|rs|rt|immediate|
|:—-:|:—-:|:—-|-|
|6 bits|5 bits|5 bits|16 bits|&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;opcode: uniquely specifies an I type instruction&lt;/li&gt;
  &lt;li&gt;rs: specifies the only register operand&lt;/li&gt;
  &lt;li&gt;rt: specifies register which will receive result of computation&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;addi, andi, slti
    &lt;ul&gt;
      &lt;li&gt;usuage: operator rt, rs, constant
 constant: 16 bits 2’s complement stored in immediate&lt;/li&gt;
      &lt;li&gt;ex: addi $s0, $s1, -50&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;lw, sw, lb, lbu, sb, lh, sh, lhu
    &lt;ul&gt;
      &lt;li&gt;usuage: operator rt, offset(rs)
 offset: stored in immediate，以 byte 為單位&lt;/li&gt;
      &lt;li&gt;ex: sw $s0, 12($s1)&lt;/li&gt;
      &lt;li&gt;lb: load a byte, sign extend to 32 bits&lt;/li&gt;
      &lt;li&gt;lbu: load a byte, zero extend to 32 bits&lt;/li&gt;
      &lt;li&gt;sb/sh: store just rightmost byte/halfword&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;beq, bne (conditiional branch)
    &lt;ul&gt;
      &lt;li&gt;usuage: operator rt, rs, label&lt;/li&gt;
      &lt;li&gt;ex: bne $s0, $s1, Exit&lt;/li&gt;
      &lt;li&gt;視 immediate 為一個 16 bits 的 2’s complement integer，用 PC-relative addressing，因為有 alignment 而且一個 instruction 都是一個 word（4 bytes） 的長度，所以 instruction 的 address 的最後兩個 bit 一定是 0，就直接省略(即使用 word address)，所以可以跳到相對於 program counter $\pm2^{17}$ bytes 的地方&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;j-type-instruction&quot;&gt;J Type Instruction&lt;/h3&gt;
&lt;p&gt;|op|target address|
|:—-:|:—-:|
|6 bits|26 bits|&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;addressing:
  |PC[31…28]|target address(26 bits)|00|
  |—-|—-|—-|
  |31~28|27~2|1~0|
  省略最後兩個 bit，缺的四個 bit 再用 program counter 的前四個 bit 來補在 28 bits 的前面，就產生 32 bits 的 address 了&lt;/li&gt;
  &lt;li&gt;usuage: j label&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;if-statement&quot;&gt;If Statement&lt;/h3&gt;
&lt;p&gt;c code:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (i == j) f = g + h;
else f = g - h;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;f, g, …, j: $s1, $s2, …. $s4&lt;/p&gt;

&lt;p&gt;MIPS code:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	bne $s3, $s4, Else
	add $s1, $s2, $s3
	j Exit
Else:	sub $s1, $s2, $s3
Exit:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;loop-statement&quot;&gt;Loop statement&lt;/h3&gt;
&lt;p&gt;c code:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (save[i] &amp;gt; k) i += 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;i in $s3, k in $s5, address of save in $s6&lt;/p&gt;

&lt;p&gt;MIPS code:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Loop:	sll $t1, $s3, 2
	add $t1, $t1, $s6
	lw $t0, 0($t1)
	slt $t2, $t0, $s5
	beq $t2, $zero, Exit
	addi $s3, $s3, 1
	j Loop
Exit: ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;procedure-call&quot;&gt;Procedure Call&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;caller: function making a call&lt;/li&gt;
  &lt;li&gt;callee: function being called&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;in caller:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;push $a0 -$a3 to stack(nested call)&lt;/li&gt;
  &lt;li&gt;put arguments in $a0 - $a3&lt;/li&gt;
  &lt;li&gt;push $t0 - $t7 to stack if needed&lt;/li&gt;
  &lt;li&gt;push $ra to stack if needed(nested call)&lt;/li&gt;
  &lt;li&gt;jal Label
    &lt;ul&gt;
      &lt;li&gt;jal: jump and link&lt;/li&gt;
      &lt;li&gt;return address in $ra&lt;/li&gt;
      &lt;li&gt;jump to target address(i.e.: Label)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;in callee:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;push $s0 - $s7 to stack before use them&lt;/li&gt;
  &lt;li&gt;perform procedure’s operations&lt;/li&gt;
  &lt;li&gt;place return value in $v0, $v1&lt;/li&gt;
  &lt;li&gt;restore $s0 - $s7&lt;/li&gt;
  &lt;li&gt;jr $ra
    &lt;ul&gt;
      &lt;li&gt;jump register&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;in caller:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;restore from stack after the call&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;32-bit-constant&quot;&gt;32-bit Constant&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lui $s0, 61
ori $s0, $s0, 2304
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;lui: load upper immediate&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第1014講-computer-arithmetic-71&quot;&gt;第10～14講 Computer Arithmetic (7/1)&lt;/h2&gt;
&lt;h3 id=&quot;alu&quot;&gt;ALU&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/oLq67o3.png&quot; alt=&quot;&quot; /&gt;
|ALUop|Function|
|—-|—-|
|0000|and|
|0001|or|
|0010|add|
|0110|subtract|
|0111|set on less than|
|1100|nor|&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ALUop: 左邊的兩個 bit 分別代表 a 和 b 要不要 invert，右邊兩個 bit 代表 1 個 4-1 的 mux 的 control signal，00 是 and，01 是 or， 10 是 add，11 在第 0 bit 為 set，在 1~31 bit 為 0&lt;/li&gt;
  &lt;li&gt;set on less than 的作法是將 1~31 bit 都設為 0，將第 0 bit 設為 a - b 的 sign bit（因為 a &amp;lt; b 即 a - b &amp;lt; 0，sign bit 會是 1，所以就直接將這個 1 拿去做為要 set 的那個 1）&lt;/li&gt;
  &lt;li&gt;nor: (a nor b) 等於 (a’ and b’)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mips-mulplication&quot;&gt;MIPS Mulplication&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ususge:
    &lt;ol&gt;
      &lt;li&gt;mult rs, rt
mfhi rd
mflo rd
        &lt;ul&gt;
          &lt;li&gt;no destination register，相乘最多有 64 bit，用兩個特殊的 register (hi, lo) 儲存&lt;/li&gt;
          &lt;li&gt;mfhi: move from high&lt;/li&gt;
          &lt;li&gt;mflo: move from low 存在指定的 register&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;mul rs, rt, rd
        &lt;ul&gt;
          &lt;li&gt;store least-significant 32 bits of product in rd&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mips-division&quot;&gt;MIPS Division&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;usuage:
div rs, rt
mfri rd
mflo rd
    &lt;ul&gt;
      &lt;li&gt;quotient stored in lo, remainder stored in hi&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;devide algorithm
&lt;img src=&quot;https://i.imgur.com/BzcDA9q.png&quot; alt=&quot;&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;問題: 為什麼在步驟一要先左移一個 bit？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;divide hardware
&lt;img src=&quot;https://i.imgur.com/WimvYTZ.png&quot; alt=&quot;&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;問題： 如果商太大（超過 32 bit 那該怎麼辦？）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;signed divide: 先當作 unsign 來做，被除數和餘數應該要同號，如果被除數和除數不同號，要把商加上負號
    &lt;ul&gt;
      &lt;li&gt;問題： 如果是 7 / (-2) 要怎麼利用這個原則？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;multiply/devide hardware
&lt;img src=&quot;https://i.imgur.com/FQ9dQnU.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;floating-point&quot;&gt;Floating Point&lt;/h3&gt;
&lt;h4 id=&quot;ieee-754-standard&quot;&gt;IEEE 754 standard&lt;/h4&gt;
&lt;p&gt;|sign|exponent|significand|
|—|—|—|&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;sign bit: 0 為正，1 為負
significand: 因為大家都是 1.xxxxxxxx，所以 leading 1 就不儲存了，這樣可以存更多個 bit
    &lt;ul&gt;
      &lt;li&gt;single precision 的有效位數是 23 + 1，double precision 的有效位數是 52 + 1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;這樣的排列方式在比大小的時候較方便&lt;/li&gt;
  &lt;li&gt;exponent 和 range 有關，significand 和精度有關&lt;/li&gt;
  &lt;li&gt;exponent 是用 biased notation 來儲存
    &lt;ul&gt;
      &lt;li&gt;biased notation (excess notation): 以 biased 7 為例，讓 0000 為最小數，1111 是最大數（為了方便比大小），把二進位當作unsign number 然後再減 7，就可以得到正確的 biased notation（減 7 的意思代表留了 7 個位置來表示負數）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;single-precision-32-bit&quot;&gt;single precision (32 bit):&lt;/h5&gt;
&lt;p&gt;|1 bit|8 bits|23 bits|
|—|—|—|&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;normalized number = $(-1)^{sign} \times 1.significand \times 2^{exponent - 127}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;special value:
  |Exponent|Significand|Object|
  |——–|———–|——|
  |0|0|+/- 0|
  |0|nonzero|denormalized underflow|
  |1-254|anything|normalized floating number|
  |255|0|+/- infinity|
  |255|nonzero|NaN|&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;normalized number 可以表示的範圍為 $-1.0 \times 2^{-126}$ 到 $(2 - 2^{-23}) \times 2^{127}$，小於$-1.0 \times 2^{-126}$ 為 underflow，大於$(2 - 2^{-23}) \times 2^{127}$ 為 overflow&lt;/li&gt;
      &lt;li&gt;有 +0 和 -0，在一些 limit comparison 時會有用&lt;/li&gt;
      &lt;li&gt;denormalized underflow: allow a number to degrate in significance until it becomes 0 (gradual underflow)
        &lt;ul&gt;
          &lt;li&gt;denormalized number = $0.significand \times 2^{-126}$&lt;/li&gt;
          &lt;li&gt;最小的 normalized number 為 $1.0000000000000000 0000000 \times 2^{-126}$&lt;/li&gt;
          &lt;li&gt;最小的 denormalized number 為 $0.000000000000 00000000001 \times 2^{-126}$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;NaN (not a number):
        &lt;ul&gt;
          &lt;li&gt;用於 debug&lt;/li&gt;
          &lt;li&gt;op(NaN,X) = NaN&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;double-precision-64-bit&quot;&gt;double precision (64 bit):&lt;/h5&gt;
&lt;p&gt;|1 bit|11 bits|52 bits|
|—|—|—|&lt;/p&gt;

&lt;h4 id=&quot;floating-point-addition&quot;&gt;Floating-Point Addition&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;algorithm:
    &lt;ol&gt;
      &lt;li&gt;align binary point: right shift the smaller number&lt;/li&gt;
      &lt;li&gt;add mantissa&lt;/li&gt;
      &lt;li&gt;normalization and check overflow/underflow during shift&lt;/li&gt;
      &lt;li&gt;round the mantissa and renormalize if necessary&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;hardware:
&lt;img src=&quot;https://i.imgur.com/qEom5zn.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;floating-point-multiplication&quot;&gt;Floating-Point Multiplication&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;algorithm:
    &lt;ol&gt;
      &lt;li&gt;add exponents of operands to get exponent of product
        &lt;ul&gt;
          &lt;li&gt;need extra subtraction step of the bias amount （因為把 exponent 加在一起時重複加了 excess 的部份）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;multiplication of mantissa&lt;/li&gt;
      &lt;li&gt;normalize the product and check overflow/underflow during shift&lt;/li&gt;
      &lt;li&gt;round the mantissa and renormalize if necessary&lt;/li&gt;
      &lt;li&gt;set the sign of product&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mips-floating-point&quot;&gt;MIPS Floating Point&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;seperate floating point instructions:
    &lt;ul&gt;
      &lt;li&gt;single precision: add.s, sub.s, mul.s, div.s&lt;/li&gt;
      &lt;li&gt;double precision: add.d, sub.d, mul.d, div.d&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;FPU:
    &lt;ul&gt;
      &lt;li&gt;contain 32 32-bit registers: $f0 - $f31&lt;/li&gt;
      &lt;li&gt;double precision: register 兩兩一組&lt;/li&gt;
      &lt;li&gt;seperate load and store: lwc1 (load a word from coprocessor 1) and swc1
        &lt;ul&gt;
          &lt;li&gt;MIPS has 4 sets of coprocessor registers.
            &lt;ul&gt;
              &lt;li&gt;Co-processor 0: Processor and system control.&lt;/li&gt;
              &lt;li&gt;Co-processor 1: MIPS-32 floating-point&lt;/li&gt;
              &lt;li&gt;Co-processor 2: Reserved for special-purpose designs.&lt;/li&gt;
              &lt;li&gt;Co-processor 3: MIPS-64 floating-point&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;The integer (GPR) registers are NOT one of the four sets.&lt;/li&gt;
          &lt;li&gt;Each set has 32 registers.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;instruction to move data between main processor and coprocessors: mfc0 (move from coprocessor 0), mtc0 (move to coprocessor 0)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;參考資料: http://www.ece.lsu.edu/ee4720/2014/lfp.s.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第1517講-single-cycle-processor-73&quot;&gt;第15～17講 Single-Cycle Processor (7/3)&lt;/h2&gt;
&lt;h3 id=&quot;storage-element&quot;&gt;Storage Element&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Register File
 &lt;img src=&quot;https://i.imgur.com/7CkBnaK.png&quot; alt=&quot;&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;consists of 32 registers&lt;/li&gt;
      &lt;li&gt;two 32-bit output buses: busA and busB
 one 32-bit input bus: busW&lt;/li&gt;
      &lt;li&gt;RA selects the register to put on busA
 RB selects the register to put on busB
 RW selects the register to be written via busW when Write Enable is 1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Memory
 &lt;img src=&quot;https://i.imgur.com/vHC1ktH.png&quot; alt=&quot;&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;one input bus: Data In
 one output bus: Data Out&lt;/li&gt;
      &lt;li&gt;address selects the word to put on Data Out
 Write Enable: address selects the memory word to be written via the Data In bus&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;datapath&quot;&gt;Datapath&lt;/h3&gt;
&lt;h4 id=&quot;a-single-cycle-datapath&quot;&gt;A Single Cycle Datapath&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Wr9VMTi.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;datapath-with-control-unit&quot;&gt;Datapath with Control Unit&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/dtd7k2o.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;datapath-with-control-and-jump-instruction&quot;&gt;Datapath with Control and Jump Instruction&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/vC0VX5y.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;control-unit&quot;&gt;Control Unit&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/QeWYwZU.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;alu-control&quot;&gt;ALU Control&lt;/h4&gt;
&lt;p&gt;|ALUop|Function|
|—-|—-|
|0000|and|
|0001|or|
|0010|add|
|0110|subtract|
|0111|set on less than|
|1100|nor|
&lt;img src=&quot;https://i.imgur.com/MnWXc8O.png&quot; alt=&quot;&quot; /&gt;
註：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;lw, sw 要加immediate，beq 則是要把 rs, rt 相減&lt;/li&gt;
  &lt;li&gt;add: 00, sub: 01, unknown: 10&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;真值表:
  &lt;img src=&quot;https://i.imgur.com/h5YQFxe.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;得到 logic equation:
    &lt;ul&gt;
      &lt;li&gt;ALUctr2 = ALUop0 + ALUop1‧func2’‧func1‧func0’
  &lt;img src=&quot;https://i.imgur.com/Z14qHdd.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;ALUctr1 = ALUop1’ + ALUop1‧func2’‧func0’
  &lt;img src=&quot;https://i.imgur.com/iixcwpD.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;ALUctr0 = ALUop1‧func3’‧func2‧func1’‧func0 + ALUop1’‧func3‧func2’‧func1‧func0’
  &lt;img src=&quot;https://i.imgur.com/jFKyGXB.png&quot; alt=&quot;&quot; /&gt;
  提問： 為什麼 func3, func2, func1, func0 不是 don’t care?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;電路圖:
  &lt;img src=&quot;https://i.imgur.com/YbwS745.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;main-control&quot;&gt;Main Control&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;真值表:
  &lt;img src=&quot;https://i.imgur.com/fBPnFnm.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;得到 logic equation&lt;/li&gt;
  &lt;li&gt;電路圖:
  &lt;img src=&quot;https://i.imgur.com/0L7x3A0.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;how-to-design-a-processor&quot;&gt;How to Design a Processor&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;analyze instruction set (datapath requirements)
    &lt;ul&gt;
      &lt;li&gt;the meaning of each instruction is given by the register transfers&lt;/li&gt;
      &lt;li&gt;datapath must include storage element&lt;/li&gt;
      &lt;li&gt;datapath must support each register transfer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;select set of datapath components and establish clocking methodology&lt;/li&gt;
  &lt;li&gt;assemble datapath meeting the requirements&lt;/li&gt;
  &lt;li&gt;analyze implementation of each instruction to determine setting of control points effecting register transfer&lt;/li&gt;
  &lt;li&gt;assemble the control logic&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;第1821講-pipelining-75&quot;&gt;第18～21講 Pipelining (7/5)&lt;/h2&gt;
&lt;h3 id=&quot;pipeline&quot;&gt;Pipeline&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;不會改善 latency，而是改善 throughput&lt;/li&gt;
  &lt;li&gt;會被最慢的 stage 所限制 （所以希望每個 stage 長度平均一點）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不同的 task 在同一時間使用不同的資源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Split Single-cycle Datapath into 5 Steps: IF(instruction fetch), ID(instruction decode and register file read), EX(execution or address calculation), MEM(data memory access), WB(write back)
&lt;img src=&quot;https://i.imgur.com/9wP075m.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加上 Pipeline Register:
&lt;img src=&quot;https://i.imgur.com/RoaTIqL.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;已經得到但還沒用到的資源也要繼續傳下去
    &lt;ul&gt;
      &lt;li&gt;例子：write register 要繼續傳下去，否則當第五個 state 結束要 write back 時會寫到新 decode 的 write register 位置
  &lt;img src=&quot;https://i.imgur.com/VWlh7o4.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;control-signal&quot;&gt;Control signal&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;control signal 跟 single cycle datapath 時並無不同，只是用 control signal 的時間不一樣&lt;/li&gt;
  &lt;li&gt;所以就根據使用的時間將 control signal 分類，用到的就可以不要了，沒用到的要繼續傳下去
&lt;img src=&quot;https://i.imgur.com/s9bYQ24.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pipeline-hazard&quot;&gt;Pipeline Hazard&lt;/h3&gt;
&lt;h4 id=&quot;structure-hazard&quot;&gt;Structure Hazard:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;不同的 instruction 同時想要去用同一個資源&lt;/li&gt;
  &lt;li&gt;解決方法：每個 intruction 要在相同的 stage 用特定的 resource
    &lt;ul&gt;
      &lt;li&gt;例子：add 在第四個 stage 就已經算完可以準備 write back 了，但因為要避免 structure hazard，需要在第五個 stage 才能 write back&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;data-hazard&quot;&gt;Data Hazard&lt;/h4&gt;
&lt;h5 id=&quot;data-hazard-and-forwarding-r-type-and-r-type&quot;&gt;Data Hazard and Forwarding (R-Type and R-Type)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;three types: (instruction i1 followed by instruction i2)
    &lt;ol&gt;
      &lt;li&gt;RAW(read after write): i2 tries to read operand before i1 write it
 &lt;img src=&quot;https://i.imgur.com/yIhGril.png&quot; alt=&quot;&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;在 cycle 5 sub 才將資料寫回 register，但是 and, or 卻在之前就想要去 register 拿資料 （add 則要看 register file 有沒有 internal forwarding，如果有那就可以拿到正確的資料）
            &lt;ul&gt;
              &lt;li&gt;internal forwarding: write in first half clock and read in second half&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;WAR(write after read): i2 tries to write aperand before i1 read it
        &lt;ul&gt;
          &lt;li&gt;i1 gets wrong operand&lt;/li&gt;
          &lt;li&gt;MIPS 不會發生，因為 i1 先執行而且 read 都是在 cycle 2&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;WAW(write after write): i2 tries to write operand before i1 write it
        &lt;ul&gt;
          &lt;li&gt;leaves wrong result (i1’s instead of i2’s); occur only in pipelines that write in more than one stage&lt;/li&gt;
          &lt;li&gt;MIPS 不會發生，因為 i2 晚 i1 一個 cycle，且 write back 都在 cycle 5&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;解決方法：
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;insert the NOPs =&amp;gt; slow us down
 &lt;img src=&quot;https://i.imgur.com/YQmSr6p.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;forwarding
 &lt;img src=&quot;https://i.imgur.com/Ew0fwBE.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;要思考 datapath 要怎麼設計（什麼時候要 forwarding），以及 control signal 要怎麼設定&lt;/li&gt;
          &lt;li&gt;datapath with forwarding
  &lt;img src=&quot;https://i.imgur.com/UBkysXh.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;hazard conditions:
            &lt;ol&gt;
              &lt;li&gt;EX/MEM.RegisterRd = ID/EX.registerRs&lt;/li&gt;
              &lt;li&gt;EX/MEM.RegisterRd = ID/EX.registerRt&lt;/li&gt;
              &lt;li&gt;MEM/WB.RegisterRd = ID/EX.registerRs&lt;/li&gt;
              &lt;li&gt;MEM/WB.RegisterRd = ID/EX.registerRt&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;Q: 這樣條件就滿足了嗎？
 A: 沒有， don’t forward if instruction does not write register =&amp;gt; check if RegWrite is asserted (如果不是 write 就根本不用 forward)&lt;/li&gt;
          &lt;li&gt;optimization:
            &lt;ul&gt;
              &lt;li&gt;don’t forward if destination register is $0 =&amp;gt; check if registerRd = 0&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;hazard conditions using control signals:
            &lt;ul&gt;
              &lt;li&gt;if both WB and MEM forward, let MEM forward
                &lt;ul&gt;
                  &lt;li&gt;例子：
                    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  add $1, $1, $2
  add $1, $1, $3
  add $1, $1, $4
&lt;/code&gt;&lt;/pre&gt;
                    &lt;/div&gt;
                    &lt;p&gt;=&amp;gt; 讓第二個 add 的 $1 forward&lt;/p&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;MEM hazard:
                &lt;ul&gt;
                  &lt;li&gt;if (EX/MEM.RegWrite and (EX/MEM.RegRd $\not=0$) and (EX/MEM.RegRd = ID/EX.RegRs))
  ForwardA = 10&lt;/li&gt;
                  &lt;li&gt;if (EX/MEM.RegWrite and (EX/MEM.RegRd $\not=0$) and (EX/MEM.RegRd = ID/EX.RegRt))
  ForwardB = 10&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;WB hazard:
                &lt;ul&gt;
                  &lt;li&gt;if (MEM/WB.RegWrite and (MEM/WB.RegRd $\not=0$) and (EX/MEM.RegRd $\not=$ ID/EX.Reg.Rs) and (MEM/WB.RegRd = ID/EX.RegRs))
  ForwardA = 01&lt;/li&gt;
                  &lt;li&gt;(MEM/WB.RegWrite and (MEM/WB.RegRd $\not=0$) and (EX/MEM.RegRd $\not=$ ID/EX.Reg.Rt) and (MEM/WB.RegRd = ID/EX.RegRt))
  ForwardB = 01&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;data-hazard-and-stalling-load-and-r-type&quot;&gt;Data Hazard and Stalling (Load and R-Type)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;如果是 lw instruction 資料要在 cycle 4 結束才能拿到，它的下一個 instruction 卻在 cycle 3 開始就需要資料運算，就算 forwarding 還是來不及
  &lt;img src=&quot;https://i.imgur.com/j92ZwWs.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;解決方法：
    &lt;ul&gt;
      &lt;li&gt;插入一個 NOP (stall)
        &lt;ul&gt;
          &lt;li&gt;把 IF/ID 設為 0&lt;/li&gt;
          &lt;li&gt;把 PC 的 WriteEnable 設為 0&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;if (ID/EX.MemRead and ((ID/EX.RegisterRt = IF/ID.Register.Rs) or (ID/EX.RegisterRt = IF/ID.Register.Rt)))
  =&amp;gt; stall the pipeline for one cycle&lt;/li&gt;
      &lt;li&gt;datapath with stall unit
  &lt;img src=&quot;https://i.imgur.com/Gzaetrz.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;control-hazard-branch-hazard&quot;&gt;Control Hazard (Branch Hazard)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在 cycle 4 才知道要不要 branch，可是如果要 branch 前面已經先讀了三個錯誤的 instruction 進來了&lt;/li&gt;
  &lt;li&gt;解決方法：
    &lt;ol&gt;
      &lt;li&gt;都先當作沒有要 branch，等真的要 branch 再把之前讀錯的 flush 掉 =&amp;gt; 每次 predict 錯都要 flush 三個 instruction，太浪費了，所以把判斷 branch 的部份拿到 cycle 2 先做
        &lt;ul&gt;
          &lt;li&gt;flush: 把 IF/ID 設為 0 或把 control signal 設為 0
        * pipeline with flush
 &lt;img src=&quot;https://i.imgur.com/NEIUa9u.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;dynamic branch prediction: 用 branch prediction buffer 來 紀錄上一次是 taken（跳） 還是 not taken（沒跳）
        &lt;ul&gt;
          &lt;li&gt;在 instruction fetch 的時候做&lt;/li&gt;
          &lt;li&gt;1-bit predictor: 只要一次錯就改 table
            &lt;ul&gt;
              &lt;li&gt;在雙層迴圈時外部迴圈每執行一次內部迴圈都會 predict 錯兩次
 =&amp;gt; 改良成 2-bit predictor，即兩次 predict 錯才改 table
  &lt;img src=&quot;https://i.imgur.com/GRg8vpb.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;even with predictor, still need to calculate target address =&amp;gt; 1-cycle penalty for a taken branch
            &lt;ul&gt;
              &lt;li&gt;branch target buffer
                &lt;ul&gt;
                  &lt;li&gt;cache of target address&lt;/li&gt;
                  &lt;li&gt;indexed by PC when instruction fetched
                    &lt;ul&gt;
                      &lt;li&gt;if hit and instruction is branch predicted taken, can fetch target immediate&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;delayed branch: 因為只需要一個 cycle，所以就 predict not taken，然後去找找看有沒有 instruction 是無論 taken 或 not taken 都需要執行的，改成執行那個 instruction，如果找不到就執行 NOP&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;exception&quot;&gt;Exception&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;非預期會發生的事件，MIPS 裡將其分為兩種：
    &lt;ol&gt;
      &lt;li&gt;exception: 在 CPU 內部發生的
        &lt;ul&gt;
          &lt;li&gt;例如：undefined opcode, overflow, syscall&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;interrupt: 從外部的 I/O 產生的&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;handling exception:
    &lt;ol&gt;
      &lt;li&gt;save PC of offending instruction
        &lt;ul&gt;
          &lt;li&gt;in MIPS: Exception Program Counter (EPC)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;save indication of the problem
        &lt;ul&gt;
          &lt;li&gt;in MIPS: Cause register: 1 bit, 0 for undefined opcode, 1 for overflow&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;jump to the handler
        &lt;ul&gt;
          &lt;li&gt;single entry: 跳到某個特定點，再根據 Cause register 看要哪個 handler 處理
            &lt;ul&gt;
              &lt;li&gt;MIPS 用 single entry&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;vectored interrupt: handler addres determined by the Cause register
        * handler action:&lt;/li&gt;
          &lt;li&gt;if restartable
            &lt;ol&gt;
              &lt;li&gt;take corrective action&lt;/li&gt;
              &lt;li&gt;use EPC to return to program&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;otherwise
            &lt;ol&gt;
              &lt;li&gt;terminate program&lt;/li&gt;
              &lt;li&gt;report error using EPC, cause&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Another form of control hazard
    &lt;ul&gt;
      &lt;li&gt;similar to mispredicted branch&lt;/li&gt;
      &lt;li&gt;在出現 exception 的那個 instruction 之前的 instruction 應該要執行完，之後的 instruction 應該要 flush 掉&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pipeline with exception
  &lt;img src=&quot;https://i.imgur.com/jo3ZG2C.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;instruction-level-parallelism-ilp&quot;&gt;Instruction-Level Parallelism (ILP)&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;deeper pipeline&lt;/li&gt;
  &lt;li&gt;multiple issue: multiple pipelines
    &lt;ul&gt;
      &lt;li&gt;Instruction Per Cycle (IPC): 因為 CPI &amp;lt; 1，所以改用 IPC&lt;/li&gt;
      &lt;li&gt;speculation: guess what to do with an instruction (要猜才能盡量的讓 pipeline 滿)
        &lt;ul&gt;
          &lt;li&gt;start an operation as soon as possible
  	* check whether guess was right
            &lt;ul&gt;
              &lt;li&gt;if so, complete the operation&lt;/li&gt;
              &lt;li&gt;if not, roll-back and do the right thing&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;例子：
            &lt;ul&gt;
              &lt;li&gt;speculate on branch outcome
                &lt;ul&gt;
                  &lt;li&gt;roll back if path taken is different&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;speculate on load (move load before store)
  			* 因為不太可能先 store 之後又馬上 load 某個資料，所以就把 load 先做，因為 load 比較花時間，如果真的發生了再 roll back&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;分成 static multiple issue 和 dynamic multiple issue
        &lt;ul&gt;
          &lt;li&gt;static multiple issue&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;compiler groups instructions into “issue packets”
        &lt;ul&gt;
          &lt;li&gt;group of instructions that can be issued on a single cycle&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;scheduling static multiple issue
        &lt;ul&gt;
          &lt;li&gt;compiler must remove some/all hazards
            &lt;ul&gt;
              &lt;li&gt;reorder instructions into issue packets&lt;/li&gt;
              &lt;li&gt;no dependencies with a packet&lt;/li&gt;
              &lt;li&gt;possibly some dependencies between packets&lt;/li&gt;
              &lt;li&gt;pad with NOP if necessary&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;MIPS with static dual issue
        &lt;ul&gt;
          &lt;li&gt;two-issue packets
            &lt;ul&gt;
              &lt;li&gt;one ALU/branch, one load/store instruction&lt;/li&gt;
              &lt;li&gt;64-bit aligned
                &lt;ul&gt;
                  &lt;li&gt;ALU/branch, then load/store&lt;/li&gt;
                  &lt;li&gt;pad on unused instruction with nop&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;rigister 變成 4 個 read port 兩個 write port，多一個 ALU
  &lt;img src=&quot;https://i.imgur.com/xoL4eg9.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;loop unrolling:
            &lt;ul&gt;
              &lt;li&gt;replicate loop body to expose more parallelism
  &lt;img src=&quot;https://i.imgur.com/gc39ME8.png&quot; alt=&quot;&quot; /&gt;
  IPC = 5/4 = 1.25
  &lt;img src=&quot;https://i.imgur.com/r5Jj1Va.png&quot; alt=&quot;&quot; /&gt;
  IPC = 14/8 = 1.75&lt;/li&gt;
              &lt;li&gt;use different registers per replication
                &lt;ul&gt;
                  &lt;li&gt;called “register renaming”&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;dynamic multiple issue&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;allow the CPU to execute instructions out of order to avoid stalls but commit result to registers in order
  &lt;img src=&quot;https://i.imgur.com/FRB0Taa.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;例子：
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  lw $t0, 20($s2)
  addu $t1, $t0, $t2
  sub $s4, $s4, $t3
  slti $t5, $s4, 20
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;can start sub while addu is waiting for lw&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;第2226講-memory-78&quot;&gt;第22～26講 Memory (7/8)&lt;/h2&gt;
&lt;h3 id=&quot;memory-technology&quot;&gt;Memory Technology&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;random access: access time same for all locations
    &lt;ul&gt;
      &lt;li&gt;SRAM:
        &lt;ul&gt;
          &lt;li&gt;low density, high power, fast&lt;/li&gt;
          &lt;li&gt;static: content will last forever until lost power&lt;/li&gt;
          &lt;li&gt;use for cache&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DRAM:
        &lt;ul&gt;
          &lt;li&gt;high density, low power, slow&lt;/li&gt;
          &lt;li&gt;dynamic: need to be fresh regularly&lt;/li&gt;
          &lt;li&gt;use for main mamory&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;magnetic disk&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;memory-hierarchy&quot;&gt;Memory Hierarchy&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/6sau7Zj.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;at any given time, data is copied between onlt two adjacent levels
    &lt;ul&gt;
      &lt;li&gt;upper level: the one closer to the processor&lt;/li&gt;
      &lt;li&gt;lower level: the one away from the processor&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;block: the basic unit of information transfer&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;two different types of locality:
    &lt;ul&gt;
      &lt;li&gt;temporal locality (locality in time)
        &lt;ul&gt;
          &lt;li&gt;ex: loop&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;spatial locality (locality in space)
        &lt;ul&gt;
          &lt;li&gt;ex: array, program&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;using the principle of locality:
    &lt;ul&gt;
      &lt;li&gt;program access a relatively small portion of the address space at any instant of time&lt;/li&gt;
      &lt;li&gt;90/10 rule: 10% of code execute 90% of time&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;terminology
    &lt;ul&gt;
      &lt;li&gt;hit: data appears in upper level
        &lt;ul&gt;
          &lt;li&gt;hit rate: fraction of memory access found in the upper level&lt;/li&gt;
          &lt;li&gt;hit time: 判斷記憶體是否hit + 把上層資料搬到處理器的時間&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;miss: data needs to be retrived from a block in the lower level
        &lt;ul&gt;
          &lt;li&gt;miss rate: 1 - (hit rate)&lt;/li&gt;
          &lt;li&gt;miss penalty: time to replace a block in the upper level + time to deliver the block to the processor&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;hit time « miss penalty&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cache&quot;&gt;Cache&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;參考資料：http://enginechang.logdown.com/tags/cache
    &lt;h4 id=&quot;direct-mapped-cache&quot;&gt;direct-mapped cache&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;block placement:
    &lt;ul&gt;
      &lt;li&gt;for each item of data at the lower level, there is exactly one location in cache where it might be&lt;/li&gt;
      &lt;li&gt;address mapping: module number of block
  &lt;img src=&quot;https://i.imgur.com/mRoZJpI.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在 cache 裡要儲存 valid bit + tag + data
    &lt;ul&gt;
      &lt;li&gt;valid bit
        &lt;ul&gt;
          &lt;li&gt;紀錄 cache 內是否為有效資訊&lt;/li&gt;
          &lt;li&gt;1 = present, 0 = not present&lt;/li&gt;
          &lt;li&gt;initially 0，因為處理器剛啟動時，內容全部是無效的&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;tag:
        &lt;ul&gt;
          &lt;li&gt;紀錄原本在記憶體的位置&lt;/li&gt;
          &lt;li&gt;不需要完整紀錄，只需要紀錄前面幾個 bit (higher ordered bit) 就好&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;block size:
    &lt;ul&gt;
      &lt;li&gt;因為有 spatial locality，所以希望一次可以搬好幾個 word 進來，也就是希望 block size 要大一點&lt;/li&gt;
      &lt;li&gt;可是在 cache 的大小固定時，block size 變大，block number 會減少，更多資料會 map 到同一個位置，miss rate 會增加&lt;/li&gt;
      &lt;li&gt;block size 變大時，miss penalty 會增加&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在剛好都要 access 餘數相同的 block 時，會一直 cache miss，可是有可能其他空間都是空的，會浪費且沒有效率，所以就思考有沒有其他更有效率使用空間的方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;associative-caches&quot;&gt;Associative Caches&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;fully associative
    &lt;ul&gt;
      &lt;li&gt;direct-mapped 是每一筆資料只能放在一個特定的位置，令一個極端就是每一筆資料可以放在任意位置，就是 fully associative，可是尋找資料的時候需要同時一次找所有的位置，太耗資源了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cache-missses&quot;&gt;Cache Missses&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;cache hit, CPU proceeds normally&lt;/li&gt;
  &lt;li&gt;cache miss
    &lt;ul&gt;
      &lt;li&gt;stall the CPU pipeline&lt;/li&gt;
      &lt;li&gt;fetch block from next level hierarchy&lt;/li&gt;
      &lt;li&gt;instruction cache miss: restart instruction fetch&lt;/li&gt;
      &lt;li&gt;data cache miss: complete data access&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;write hit
    &lt;ul&gt;
      &lt;li&gt;write through: also update the cache
        &lt;ul&gt;
          &lt;li&gt;avoid waiting for memory in write through: use a write buffer
            &lt;ul&gt;
              &lt;li&gt;write buffer:
                &lt;ul&gt;
                  &lt;li&gt;holding data waiting to be written to memory, CPU continues immediately (only stall on write if write buffer is already full)&lt;/li&gt;
                  &lt;li&gt;FIFO&lt;/li&gt;
                  &lt;li&gt;typical number of entries: 4&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;write back: on data-write hit, just update the block in cache
        &lt;ul&gt;
          &lt;li&gt;keep track of whether each block is dirty&lt;/li&gt;
          &lt;li&gt;when a dirty block is replaced
            &lt;ul&gt;
              &lt;li&gt;write it back to the memory&lt;/li&gt;
              &lt;li&gt;can use a write buffer to allow replacing block to be read first&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;write miss
    &lt;ul&gt;
      &lt;li&gt;write through: 直接去寫 memory（don’t fetch the block）&lt;/li&gt;
      &lt;li&gt;write back: fetch the block&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cache-performance&quot;&gt;Cache Performance&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;with simplifying asssumptions:
$Memory\ stall\ cycles \ = \frac{Memory\ accesses}{Program} \times Miss\ rate \times Miss\ penalty \ = \frac {Insructions}{Program} \times \frac{Misses}{Instruction} \times Miss\ penalty$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$Average\ Memory\ Access\ Time\ (AMAT) = hit\ time + miss\ rate \times miss\ penalty$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Actual CPI = base CPI + Miss CPI&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;main-memory&quot;&gt;Main Memory&lt;/h3&gt;
&lt;h4 id=&quot;memory-design-to-support-cache&quot;&gt;Memory Design to Support Cache&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/1rJkIOl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use interleaved memory orginization
    &lt;ul&gt;
      &lt;li&gt;速度比 one-word-wide memory organization 快，硬體比 wide memory orginization 少&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;access-of-dram&quot;&gt;Access of DRAM&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;將記憶體位置分為前半部和後半部，先讀前半部得到一個 row，再從後半部取得 column&lt;/li&gt;
&lt;/ul&gt;</content><author><name>chadcoco1444</name><email>chadcoco1444@gmail.com</email></author><category term="Computer" /><category term="Organization" /><category term="Structure" /><summary type="html">計算機組織結構 參考資料：http://www.ece.lsu.edu/ee4720/ 第01講 Course Outline (6/25) Q: 為什麼電腦不用十進位而用二進位？ A: signal 的 voltage 只能分成 high 和 low =&amp;gt; 只能有兩種state 電子電路： switch(n-type transistor): three terminals: the source, the gate, and the drain. 開： 在 gate加電壓 =&amp;gt; 產生 eletron channel 在 source 和 drain 之間 在 source 和 drain 之間加電位差 =&amp;gt; 產生電流 關：移除 gate 的電壓</summary></entry></feed>